void printF()
{
    output = createWriter("record\\record_"+numOfFile+"\\box.pde");
    saveData="class Box \n{\n    Body body;                                                 //box2D body\n    float w,h;                                                 //width & height\n    color col;                                                 //color\n    Box(float x, float y,float w_,float h_,color col_)                    //scan position & shape data\n    {\n        w = w_;                                                //initialization\n        h = h_;                                                //initialization\n        col=col_;                                            //initialization\n        BodyDef bd = new BodyDef();                            //apply memory for body defition\n        bd.type = BodyType.DYNAMIC;                            //boxes are dynamic\n        bd.position.set(box2d.coordPixelsToWorld(x,y));        //set position\n        body = box2d.createBody(bd);                           //create body by defition\n        PolygonShape sd = new PolygonShape();                  //apply memory for shape\n        sd.setAsBox(box2d.scalarPixelsToWorld(w/2), box2d.scalarPixelsToWorld(h/2));      //set shape by width & height\n        FixtureDef fd = new FixtureDef();                      //apply memory for fixture\n        fd.shape = sd;                         //shape\n        fd.density = 1;                        //density\n        fd.friction = 0.3;                     //friction\n        fd.restitution = 0.5;                  //elasticity\n        body.createFixture(fd);                //set body physical property by fixture\n    }\n    boolean done() \n    {\n        Vec2 pos = box2d.getBodyPixelCoord(body);              //get the position of body now\n        if(pos.y > height+w*2||pos.y<-height||pos.x>width*2||pos.x<-width)  //when body go out of the world\n        {\n            box2d.destroyBody(body);                           //kill the body\n            return true;\n        }\n        return false;\n    }\n    void display() \n    {\n        strokeWeight(1);                                   //weight of stroke is 1\n        Vec2 pos = box2d.getBodyPixelCoord(body);          //get the position of body now\n        float a = body.getAngle();                         //get the acceleration of body now\n        pushMatrix();                                      //push\n        translate(pos.x,pos.y);                            //(0,0) -> position\n        rotate(-a);                                        //rotate a\n        fill(col);                                         //set the color of box\n        stroke(0);                                         //set the color of stroke\n        rectMode(CENTER);                                  //display from center\n        rect(0,0,w,h);                                     //display the box\n        popMatrix();                                       //pop\n    }\n    void killBody()\n    {\n        box2d.destroyBody(body);\n    }\n}";
    output.print(saveData);
    output.flush();     // writes the remaining data to the file
    output.close();     // finishes the file
    output = createWriter("record\\record_"+numOfFile+"\\bomb.pde");
    saveData="class Bomb\n{\n    Body body;                  //box2D body\n    float r,moveX,moveY;        //radiu & position to move\n    FixtureDef fd;              //body defition\n    float time;\n    Bomb(float x, float y, float r_,float time_)\n    {\n        r = r_;                        \n        time=time_;                    //initialization\n        fd = new FixtureDef();         //apply memory for body defition\n        makeBody(x, y, r);             //gave boom a body\n        body.setUserData(this);\n    }\n    boolean done() \n    {\n        Vec2 pos = box2d.getBodyPixelCoord(body);\n        if (pos.y > height+r*2||pos.y<-height||pos.x>width*2||pos.x<-width) \n        {\n            box2d.destroyBody(body);\n            return true;\n        }\n        return false;\n    }\n    void display()\n    {\n        Vec2 pos = box2d.getBodyPixelCoord(body);           //get position\n        float a = body.getAngle();\n        pushMatrix();                                       //push\n        translate(pos.x, pos.y);\n        rotate(-a);\n        image(imgBomb_1,-r,-r,2*r,2*r);\n        tint(255,255-time);\n        image(imgBomb_2,-r,-r,2*r,2*r);\n        tint(255,255);                                      //heighlight\n        popMatrix();                                        //pop\n    }\n    void makeBody(float x, float y, float r)                //make body just like grain\n    {\n        CircleShape cs = new CircleShape();\n        cs.m_radius = box2d.scalarPixelsToWorld(r);\n        fd.shape = cs;\n        fd.density = 0.005;\n        fd.friction = 1;\n        fd.restitution= Restitution;\n        BodyDef bd = new BodyDef();\n        bd.position = box2d.coordPixelsToWorld(x, y);\n        bd.type = BodyType.DYNAMIC;\n        body = box2d.createBody(bd);\n        body.createFixture(fd);\n        body.setAngularVelocity( 0 );\n    }\n    boolean over()\n    {\n        if((mouseX-box2d.getBodyPixelCoord(body).x)*(mouseX-box2d.getBodyPixelCoord(body).x)+(mouseY-box2d.getBodyPixelCoord(body).y)* (mouseY-box2d.getBodyPixelCoord(body).y)<=r*r)\n        {                                              //x^2 + y^2 <= r^2\n            return true;\n        }\n        return false;\n    }\n    void move(float x_,float y_)                                        //follow mouse\n    {\n        Vec2 vel=body.getLinearVelocity();\n        float a = body.getAngle();\n        box2d.destroyBody(body);\n        makeBody(x_-moveX,y_-moveY,r);\n        body.setLinearVelocity(vel);\n        body.setAngularVelocity(a);\n    }\n}";
    output.print(saveData);
    output.flush();     // writes the remaining data to the file
    output.close();     // finishes the file
    output = createWriter("record\\record_"+numOfFile+"\\bridge.pde");
    saveData="class Bridge \n{\n    float totalLength;\n    int numPoints;\n    ArrayList<Particle> particles;\n    ArrayList<DistanceJoint> joints;\n    Vec2 start;\n    Vec2 end;\n    Bridge(Vec2 _start, Vec2 _end)\n    {\n        start=_start;\n        end=_end;\n        totalLength = sqrt((start.x-end.x)*(start.x-end.x)+(start.y-end.y)*(start.y-end.y));\n        numPoints = int(totalLength/10);\n        particles = new ArrayList<Particle>();\n        joints=new ArrayList<DistanceJoint>();\n        float lenX = (end.x-start.x) / numPoints;\n        float lenY = (end.y-start.y) / numPoints;\n        float len=sqrt(lenX*lenX+lenY*lenY);\n        Particle p = new Particle(start.x,start.y,6,3,5,BodyType.STATIC);\n        particles.add(p);\n        for(int i=1;i<numPoints;i++)\n        {\n            p = new Particle(start.x+i*lenX,start.y+i*lenY,6,3,5,BodyType.DYNAMIC);\n            particles.add(p);\n            DistanceJointDef djd = new DistanceJointDef();\n            djd.bodyA = particles.get(i-1).body;\n            djd.bodyB = p.body;\n            djd.length = box2d.scalarPixelsToWorld(len);\n            djd.frequencyHz = 0;\n            djd.dampingRatio = 0;\n            box2d.world.createJoint(djd);\n        }\n        p = new Particle(end.x,end.y,6,3,5,BodyType.STATIC);\n        particles.add(p);\n        DistanceJointDef djd = new DistanceJointDef();\n        djd.bodyA = particles.get(particles.size()-2).body;\n        djd.bodyB = p.body;\n        djd.length = box2d.scalarPixelsToWorld(len);\n        djd.frequencyHz = 0;\n        djd.dampingRatio = 0;\n        joints.add((DistanceJoint)box2d.world.createJoint(djd));\n    }\n    void display()\n    {\n        for (Particle p: particles)\n        {\n            p.display();\n        }\n    }\n    void killBody()\n    {\n        for(DistanceJoint j:joints)\n        {\n            box2d.world.destroyJoint(j);\n        }\n        for(Particle p:this.particles)\n        {\n            p.killBody();\n        }\n    }\n}";
    output.print(saveData);
    output.flush();     // writes the remaining data to the file
    output.close();     // finishes the file
    output = createWriter("record\\record_"+numOfFile+"\\dot.pde");  
    saveData="class Dot\n{\n    float x,y,r;           //position & radiu\n    Dot(float x_,float y_,float r_)\n    {\n        x=x_;\n        y=y_;\n        r=r_;              //initialization\n    }\n    boolean over()\n    {\n        if((mouseX-x)*(mouseX-x)+(mouseY-y)* (mouseY-y)<=r*r)        //mouse is over the dot?\n        {\n            return true;\n        }\n        return false;\n    }\n    void display()                       //display the dot\n    {\n        noFill();\n        strokeWeight(1);\n        ellipse(x,y, r*2, r*2);\n        line(x-5,y,x+5,y);\n        line(x,y-5,x,y+5);\n    }\n    void attractionOn()\n    {\n        for(Particle p: particles)      //attracted all balls\n        {\n            Vec2 worldTarget = box2d.coordPixelsToWorld(x,y);        //position of attraction point in the world\n            Vec2 bodyVec = p.body.getWorldCenter();                  //position of ball\'s body in the world\n            worldTarget.subLocal(bodyVec);                           //set position of ball\n            worldTarget.normalize();                                 //normalize\n            worldTarget.mulLocal((float) 10);                        //attractive force = 10N\n            p.body.applyForce(worldTarget, bodyVec);                 //open attraction\n        }\n        for(Grain g:grains)             //attracted all grains\n        {\n            Vec2 worldTarget = box2d.coordPixelsToWorld(x,y);        //position of attraction point in the world\n            Vec2 bodyVec = g.body.getWorldCenter();                  //position of grain\'s body in the world\n            worldTarget.subLocal(bodyVec);                           //set position of grain\n            worldTarget.normalize();                                 //normalize\n            worldTarget.mulLocal((float) 10);                        //attractive force = 10N\n            g.body.applyForce(worldTarget, bodyVec);                 //open attraction\n        }\n    }\n    void move(float x_,float y_)                //follow with mouse\n    {\n        x=x_;\n        y=y_;\n    }\n}";
    output.print(saveData);
    output.flush();     // writes the remaining data to the file
    output.close();     // finishes the file
    output = createWriter("record\\record_"+numOfFile+"\\grain.pde");
    saveData="class Grain\n{\n    Body body;                          //box2D body\n    float r;                            //radius\n    color col;                          //color\n    Grain(float x, float y,float r_,color col_) \n    {\n        r=r_;                  //initialization\n        col=col_;      //initialization\n        FixtureDef fd = new FixtureDef();                    //apply memory for body defition\n        CircleShape cs = new CircleShape();                  //apply memory for shape\n        cs.m_radius = box2d.scalarPixelsToWorld(r);          //build shape by radius\n        fd.shape = cs;                                       //set shape\n        fd.density = 0.1;                                    //density\n        fd.friction = 0;                                     //friction\n        fd.restitution= 1;                                   //elasticity\n        BodyDef bd = new BodyDef();                          //apply memory for body defition\n        bd.position = box2d.coordPixelsToWorld(x, y);        //set position\n        bd.type = BodyType.DYNAMIC;                          //grains are dynamic\n        body = box2d.createBody(bd);                         //create body by defition\n        body.createFixture(fd);                              //set body physical property by fixture\n        body.setAngularVelocity(0);                          //angular velocity is 0\n    }\n    boolean done() \n    {\n        Vec2 pos = box2d.getBodyPixelCoord(body);            //get position of body in the world\n        if(pos.y > height+r*2||pos.y<-height||pos.x>width*2||pos.x<-width)         //go out from the world?\n        {\n            box2d.destroyBody(body);                         //kill the body\n            return true;\n        }\n        return false;\n    }\n    void display() \n    {\n        strokeWeight(1);\n        Vec2 pos = box2d.getBodyPixelCoord(body);            //get position of body in the world\n        pushMatrix();                                        //push\n        translate(pos.x,pos.y);\n        fill(col);\n        stroke(0);\n        rectMode(CENTER);\n        ellipse(0,0,r*2,r*2);\n        popMatrix();                                         //pop\n    }\n}";
    output.print(saveData);
    output.flush();     // writes the remaining data to the file
    output.close();     // finishes the file
    output = createWriter("record\\record_"+numOfFile+"\\particle.pde");
    saveData="class Particle \n{\n    Body body;                  //box2D body\n    float r,moveX,moveY;        //radiu & position to move\n    PImage imgBall;             //image of the ball\n    FixtureDef fd;              //body defition\n    Particle(float x, float y, float r_,float d_)\n    {\n        r = r_;                        //initialization\n        fd = new FixtureDef();         //apply memory for body defition\n        makeBody(x, y, r, 0.005,BodyType.DYNAMIC);             //gave ball a body\n        body.setUserData(this);\n        imgBall=d_>1?imgBall_1:imgBall_3;            //random ball\n    }\n    Particle(float x, float y, float r_,float d_,float den,org.jbox2d.dynamics.BodyType bt)\n    {\n        r = r_;                        //initialization\n        fd = new FixtureDef();         //apply memory for body defition\n        makeBody(x, y, r, den,bt);             //gave ball a body\n        body.setUserData(this);\n        if(d_==3)\n        {\n            imgBall=imgBridge;\n        }\n        else\n        {\n            imgBall=d_>1?imgBall_1:imgBall_3;            //random ball\n        }\n    }\n    boolean done() \n    {\n        Vec2 pos = box2d.getBodyPixelCoord(body);\n        if (pos.y > height+r*2||pos.y<-height||pos.x>width*2||pos.x<-width) \n        {\n            killBody();\n            return true;\n        }\n        return false;\n    }\n    void killBody()\n    {\n        box2d.destroyBody(body);\n    }\n    void display()\n    {\n        Vec2 pos = box2d.getBodyPixelCoord(body);           //get position\n        float a = body.getAngle();\n        pushMatrix();                                       //push\n        translate(pos.x, pos.y);\n        image(imgBall_2,-r,-r,2*r,2*r);\n        rotate(-a);\n        image(imgBall,-r,-r,2*r,2*r);                       //heighlight\n        popMatrix();                                        //pop\n    }\n    void makeBody(float x, float y, float r,float den,org.jbox2d.dynamics.BodyType bt)                //make body just like grain\n    {\n        CircleShape cs = new CircleShape();\n        cs.m_radius = box2d.scalarPixelsToWorld(r);\n        fd.shape = cs;\n        fd.density = den;\n        fd.friction = 1;\n        fd.restitution= Restitution;\n        BodyDef bd = new BodyDef();\n        bd.position = box2d.coordPixelsToWorld(x, y);\n        bd.type = bt;\n        body = box2d.createBody(bd);\n        body.createFixture(fd);\n        body.setAngularVelocity( 0 );\n    }\n    boolean over()\n    {\n        if((mouseX-box2d.getBodyPixelCoord(body).x)*(mouseX-box2d.getBodyPixelCoord(body).x)+(mouseY-box2d.getBodyPixelCoord(body).y)* (mouseY-box2d.getBodyPixelCoord(body).y)<=r*r)\n        {                                              //x^2 + y^2 <= r^2\n            return true;\n        }\n        return false;\n    }\n    void move(float x_,float y_)                                        //follow mouse\n    {\n        Vec2 vel=body.getLinearVelocity();\n        float a = body.getAngle();\n        box2d.destroyBody(body);\n        makeBody(x_-moveX,y_-moveY,r, 0.005,BodyType.DYNAMIC);\n        body.setLinearVelocity(vel);\n        body.setAngularVelocity(a);\n    }\n}";
    output.print(saveData);
    output.flush();     // writes the remaining data to the file
    output.close();     // finishes the file
    output = createWriter("record\\record_"+numOfFile+"\\surface.pde");
    saveData="class Surface\n{\n    ArrayList<Vec2> surface;                                          //statement arraylists\n    Body body;                                                        //box2D body\n    Surface()\n    {\n        surface = new ArrayList<Vec2>();                              //apply memory for arraylists\n        ChainShape chain = new ChainShape();\n        for(Vec2 v:surfaces)\n        {\n            surface.add(v);                                           //copy positions\n        }\n        Vec2[] vertices = new Vec2[surfaces.size()];                  //apply memory for vertices[]\n        for(int i = 0; i < vertices.length; i++) \n        {\n            vertices[i]=box2d.coordPixelsToWorld(surface.get(i));     //get position from surface\n        }\n        chain.createChain(vertices,vertices.length);                  //set shape by vertices[]\n        BodyDef bd = new BodyDef();\n        bd.position.set(0.0f,0.0f);\n        body = box2d.createBody(bd);\n        body.createFixture(chain,1);\n    }\n    void display()                                                    //display by surface\n    {\n        strokeWeight(3);\n        for(int i=1;i<surface.size();i++)\n        {\n            line(surface.get(i-1).x,surface.get(i-1).y,surface.get(i).x,surface.get(i).y);\n        }\n    }\n    boolean split(float x0,float y0)\n    {\n        boolean del=false;\n        surfaces=new ArrayList<Vec2>();\n        float x1=surface.get(0).x,y1=surface.get(0).y,r_2=width*height*0.0004;\n        float k,b,A,B,C,x3,y3,x4,y4,x2=0,y2=0;\n        for(int i=1;i<surface.size();i++,x1=x2,y1=y2)\n        {\n            x2=surface.get(i).x;\n            y2=surface.get(i).y;\n            if(x2-x1==0)\n            {\n                if(r_2-(x1-x0)*(x1-x0)<0)\n                {\n                    surfaces.add(new Vec2(x1,y1));\n                    continue;\n                }\n                else\n                {\n                    x3=x4=x1;\n                    y3=y0-sqrt(r_2-(x1-x0)*(x1-x0));\n                    y4=y0+sqrt(r_2-(x1-x0)*(x1-x0));\n                }\n            }\n            else\n            {\n                k=(y2-y1)/(x2-x1);\n                b=y1-x1*k;\n                A=1+k*k;\n                B=-2*x0+2*k*(b-y0);\n                C=(b-y0)*(b-y0)+x0*x0-r_2;\n                if(B*B-4*A*C<0)\n                {\n                    surfaces.add(new Vec2(x1,y1));\n                    continue;\n                }\n                x3=(-B+sqrt(B*B-4*A*C))/(2*A);\n                x4=(-B-sqrt(B*B-4*A*C))/(2*A);\n                y3=x3*k+b;\n                y4=x4*k+b;\n            }\n            fill(#123456);\n            ellipse(x3,y3,20,20);\n            ellipse(x4,y4,20,20);\n       \n       \n            if((x1-x0)*(x1-x0)+(y1-y0)*(y1-y0)<r_2)\n            {\n                if(!del)\n                {\n                    del=true;\n                }\n                if((x2-x0)*(x2-x0)+(y2-y0)*(y2-y0)<r_2)\n                {\n                    continue;\n                }\n                if(((x3<=x2&&x3>=x1)||(x3>=x2&&x3<=x1))&&((y3<y2&&y3>=y1)||(y3>=y2&&y3<=y1)))\n                {\n                    surfaces.add(new Vec2(x3,y3));\n                }\n                else\n                {\n                    surfaces.add(new Vec2(x4,y4));\n                }\n                continue;\n            }\n            if((x2-x0)*(x2-x0)+(y2-y0)*(y2-y0)<r_2)\n            {\n                if(!del)\n                {\n                    del=true;\n                }\n                surfaces.add(new Vec2(x1,y1));\n                if(((x3<=x2&&x3>=x1)||(x3>=x2&&x3<=x1))&&((y3<=y2&&y3>=y1)||(y3>=y2&&y3<=y1)))\n                {\n                    surfaces.add(new Vec2(x3,y3));\n                }\n                else\n                {\n                    surfaces.add(new Vec2(x4,y4));\n                }\n                for(int t=surfaces.size()-2;t>=0;t--)\n                {\n                    if((surfaces.get(t).x-surfaces.get(t+1).x)<0.5&&(surfaces.get(t).x-surfaces.get(t+1).x)>-0.5&&(surfaces.get(t).y-surfaces.get(t+1).y)<0.5&&(surfaces.get(t).y-surfaces.get(t+1).y)>-0.5)\n                    {\n                        surfaces.remove(t);\n                    }\n                }\n                if(surfaces.size()>1)\n                {\n                    lines.add(new Surface());\n                }\n                surfaces=new ArrayList<Vec2>();\n                continue;\n            }\n            if(((x3<=x1&&x3<=x2)||(x3>=x1&&x3>=x2))&&((y3<=y1&&y3<=y2)||(y3>=y1&&y3>=y2)))\n            {\n                surfaces.add(new Vec2(x1,y1));\n                continue;\n            }\n            if(!del)\n            {\n                del=true;\n            }\n            \n            surfaces.add(new Vec2(x1,y1));\n            if(((x1<=x3&&x3<=x4)||(x1>=x3&&x3>=x4))&&((y1<=y3&&y3<=y4)||(y1>=y3&&y3>=y4)))\n            {\n                surfaces.add(new Vec2(x3,y3));\n                for(int t=surfaces.size()-2;t>=0;t--)\n                {\n                    if((surfaces.get(t).x-surfaces.get(t+1).x)<0.5&&(surfaces.get(t).x-surfaces.get(t+1).x)>-0.5&&(surfaces.get(t).y-surfaces.get(t+1).y)<0.5&&(surfaces.get(t).y-surfaces.get(t+1).y)>-0.5)\n                    {\n                        surfaces.remove(t);\n                    }\n                }\n                if(surfaces.size()>1)\n                {\n                    lines.add(new Surface());\n                }\n                surfaces=new ArrayList<Vec2>();\n                surfaces.add(new Vec2(x4,y4));\n            }\n            else\n            {\n                surfaces.add(new Vec2(x4,y4));\n                for(int t=surfaces.size()-2;t>=0;t--)\n                {\n                    if((surfaces.get(t).x-surfaces.get(t+1).x)<0.5&&(surfaces.get(t).x-surfaces.get(t+1).x)>-0.5&&(surfaces.get(t).y-surfaces.get(t+1).y)<0.5&&(surfaces.get(t).y-surfaces.get(t+1).y)>-0.5)\n                    {\n                        surfaces.remove(t);\n                    }\n                }\n                if(surfaces.size()>1)\n                {\n                    lines.add(new Surface());\n                }\n                surfaces=new ArrayList<Vec2>();\n                surfaces.add(new Vec2(x3,y3));\n            }\n        }\n        if(del)\n        {\n            if((x2-x0)*(x2-x0)+(y2-y0)*(y2-y0)>r_2)\n            {\n                surfaces.add(new Vec2(x2,y2));\n            }\n            for(int t=surfaces.size()-2;t>=0;t--)\n            {\n                if((surfaces.get(t).x-surfaces.get(t+1).x)<0.5&&(surfaces.get(t).x-surfaces.get(t+1).x)>-0.5&&(surfaces.get(t).y-surfaces.get(t+1).y)<0.5&&(surfaces.get(t).y-surfaces.get(t+1).y)>-0.5)\n                {\n                    surfaces.remove(t);\n                }\n            }\n            if(surfaces.size()>1)\n            {\n                lines.add(new Surface());\n            }\n        }\n        surfaces=new ArrayList<Vec2>();   \n        return del;\n    }\n}";
    output.print(saveData);
    output.flush();     // writes the remaining data to the file
    output.close();     // finishes the file
    output = createWriter("record\\record_"+numOfFile+"\\display.pde");
    saveData="void Display()\n{\n    for(int i = boxes.size()-1; i >= 0; i--)\n    {\n        Box b = boxes.get(i);\n        if (b.done())\n        {\n            boxes.remove(i);\n        }\n    }                                                //check boxes\n    for(int i = particles.size()-1; i >= 0; i--)\n    {\n        Particle p = particles.get(i);\n        if (p.done())\n        {\n            particles.remove(i);\n        }\n    }                                               //check balls and numOfChoose\n    for(int i = bombs.size()-1; i >= 0; i--)\n    {\n        Bomb b = bombs.get(i);\n        if (b.done())\n        {\n            bombs.remove(i);\n        }\n        float pX=0,bX=0,pY=0,bY=0;\n        if(b.time--==0)\n        {\n            for(int j = particles.size()-1; j >= 0; j--)\n            {\n                pX=box2d.getBodyPixelCoord(particles.get(j).body).x;\n                bX=box2d.getBodyPixelCoord(b.body).x;\n                pY=box2d.getBodyPixelCoord(particles.get(j).body).y;\n                bY=box2d.getBodyPixelCoord(b.body).y;\n                if((pX-bX)*(pX-bX)+(pY-bY)*(pY-bY)<=b.r*b.r*9)\n                {\n                    particles.get(j).body.applyForce(new Vec2((pX-bX)*10,(bY-pY)*10), particles.get(j).body.getWorldCenter());\n                }\n            }\n            for(int j = grains.size()-1; j >= 0; j--)\n            {\n                pX=box2d.getBodyPixelCoord(grains.get(j).body).x;\n                bX=box2d.getBodyPixelCoord(b.body).x;\n                pY=box2d.getBodyPixelCoord(grains.get(j).body).y;\n                bY=box2d.getBodyPixelCoord(b.body).y;\n                if((pX-bX)*(pX-bX)+(pY-bY)*(pY-bY)<=b.r*b.r*9)\n                {\n                    grains.get(j).body.applyForce(new Vec2((pX-bX)*10,(bY-pY)*10), grains.get(j).body.getWorldCenter());\n                }\n            }\n            box2d.destroyBody(b.body);\n            bombs.remove(i);\n        }\n    }\n    for(int i = grains.size()-1; i >= 0; i--)\n    {\n        Grain g = grains.get(i);\n        if (g.done())\n        {\n            grains.remove(i);\n        }\n    }                                               //check grains\n    for(Bomb b:bombs)\n    {\n        b.display();\n    }                                               //display bombs\n    for(Dot d:dots)\n    {\n        d.display();\n    }                                               //display dots\n    for(Surface s:lines)\n    {\n        s.display();\n    }                                               //display lines\n    for(Particle p:particles)\n    {\n        p.display(); \n    }                                               //display balls\n    for(Grain g:grains)\n    {\n        g.display(); \n    }                                               //display grains\n    for(Paddle p:paddles)\n    {\n        p.display(); \n    }\n    for(Box b:boxes)\n    {\n        b.display(); \n    }                                               //display boxes\n    for(Bridge b:bridges)\n    {\n        b.display();\n    }                                               //display bridges;                                               //display rockers\n    if(oWall)\n    {\n        wall.display();\n    }                                               //display the wall\n    \n}";
    output.print(saveData);
    output.flush();     // writes the remaining data to the file
    output.close();     // finishes the file
    output = createWriter("record\\record_"+numOfFile+"\\paddle.pde");
    saveData = "class Paddle\n{\n    float w,h;\n    Body body;\n    FixtureDef fd;\n\n    Paddle(float x, float y,float w_,float h_)                    //scan position & shape data\n    {\n        w = w_;                                                //initialization\n        h = h_;                                                //initialization\n        fd = new FixtureDef(); \n        makeBody(x,y,w,h);\n    }\n    \n    void makeBody(float x, float y, float w,float h)                //make body just like grain\n    {\n        BodyDef bd = new BodyDef();\n        PolygonShape sd = new PolygonShape();\n        bd.position = box2d.coordPixelsToWorld(x, y);\n        sd.setAsBox(box2d.scalarPixelsToWorld(w/2), box2d.scalarPixelsToWorld(h/2));\n        fd.shape=sd;\n        bd.type = BodyType.STATIC; \n        body = box2d.createBody(bd);\n        body.createFixture(fd);\n        body.setUserData(this);\n    }\n    \n    void display() \n    {\n        Vec2 pos = box2d.getBodyPixelCoord(body);          //get the position of body now\n        pushMatrix();                                      //push\n        translate(pos.x,pos.y);                            //(0,0) -> position\n        rectMode(CENTER);                                  //display from center\n        image(imgPaddle,-w/2,-h/2,w,h);\n        popMatrix();                                       //pop\n    }\n    \n    void killBody()\n    {\n        box2d.destroyBody(body);\n    }\n    \n    boolean over()\n    {\n        if(mouseX>=box2d.getBodyPixelCoord(body).x-w/2&&mouseX<=box2d.getBodyPixelCoord(body).x+w/2&&mouseY>=box2d.getBodyPixelCoord(body).y-h/2&&mouseY<=box2d.getBodyPixelCoord(body).y+h/2)\n        {\n            return true;\n        }\n        return false;\n    }\n    void move(float x,float y)\n    {\n            killBody();\n            makeBody(x,y,w,h);\n    }\n}";
    output.print(saveData);
    output.flush();     // writes the remaining data to the file
    output.close();     // finishes the file
                        //class data
                        /***********************************************************************/
                        //main data
    output = createWriter("record\\record_"+numOfFile+"\\record_"+numOfFile+".pde");
    saveData="import shiffman.box2d.*;\nimport org.jbox2d.common.*;\nimport org.jbox2d.dynamics.joints.*;\nimport org.jbox2d.collision.shapes.*;\nimport org.jbox2d.collision.shapes.*;\nimport org.jbox2d.common.*;\nimport org.jbox2d.dynamics.*;\nimport org.jbox2d.dynamics.contacts.*;\nBox2DProcessing box2d;\n                                                 //import box2D\nArrayList<Particle> particles;\nArrayList<Dot> dots;\nArrayList<Box> boxes;\nArrayList<Grain> grains;\nArrayList<Vec2> surfaces;\nArrayList<Surface> lines;\nArrayList<Bomb> bombs;\nArrayList<Bridge> bridges;\nArrayList<Paddle> paddles;\n                                                 //statement arraylists\nPImage imgBall_1,imgBall_2,imgBall_3,imgBomb_1,imgBomb_2,imgBridge,imgBackground,imgPaddle;\nint Restitution=0,numOfChoose=-1,timer=-1;\nboolean oDot=false,oAtt=false,oStep=true,oWall=false,oBridge=false,oBomb=false;\nSurface wall;      //statement walls\nvoid setup()\n{\n    size(displayWidth,displayHeight,P3D);                //Full screen\n    particles = new ArrayList<Particle>();\n    dots = new ArrayList<Dot>();\n    paddles = new ArrayList<Paddle>();\n    boxes=new ArrayList<Box>();\n    surfaces=new ArrayList<Vec2>();\n    paddles=new ArrayList<Paddle>();\n    lines=new ArrayList<Surface>();\n    grains=new ArrayList<Grain>();\n    bombs=new ArrayList<Bomb>();\n    bridges=new ArrayList<Bridge>();\n    imgBall_1=loadImage(\"ball_1.png\");\n    imgBall_2=loadImage(\"ball_2.png\");\n    imgBall_3=loadImage(\"ball_3.png\");\n    imgBomb_1=loadImage(\"bomb_1.png\");\n    imgBomb_2=loadImage(\"bomb_2.png\");\n    imgBackground=loadImage(\"background.png\");\n    imgPaddle=loadImage(\"paddle.png\");\n    imgBridge=loadImage(\"bridge.png\");\n    box2d = new Box2DProcessing(this);                   //apply memory for the world\n    box2d.createWorld();               //create the world\n    box2d.setGravity(0,0);             //initial g=0 just like weightlessness\n    frameRate(40);                     //limit number of frames\n    orientation(LANDSCAPE);            //ban turn screen\n}\nvoid draw()\n{\n    drawing();\n}\nvoid drawing()\n{\n    background(255);\n    image(imgBackground,0,0,displayWidth,displayHeight);\n    if(oStep){ box2d.step();\n    if(oAtt)\n    {\n        for(Dot d:dots)\n        {\n            d.attractionOn();\n        }\n    }\n}\n    timer++;\n    switch(timer)\n    {\n";
    output.print(saveData);
}